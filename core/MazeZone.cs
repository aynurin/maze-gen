using System;
using System.Collections.Generic;

namespace Nour.Play.Maze {
    // ? The issue is that Halls can be entered, so they should act as cells,
    // ? and Fills can't be entered, so they are invisible to all algorithms. 
    // ? For Dijkstra, Halls should act as regular cells, but with increased passing
    // ? complexity.
    // Zone size definition: Given that the mazes can be autogenerated and of
    // different sizes, we can't easily predefine zones counts and sizes, so we
    // might want to calculate zones based on some kind of rules. E.g., see
    // RandomZoneGenerator.
    // TODO: Create a zone generator
    // TODO: Update generators to honor zones
    // TODO: Update Dijkstra to use hall sizes
    public class MazeZone {
        public ZoneType Type { get; private set; }
        public string[] Tags { get; private set; }
        public Size Size { get; private set; }

        public MazeZone(ZoneType type, Size size, params string[] tags) {
            Type = type;
            Size = size;
            Tags = tags;
        }

        public MazeZone Rotate2d() {
            return new MazeZone(Type, Size.Rotate2d(), Tags);
        }

        public enum ZoneType {
            None = 0,
            /// E.g., a hall with walls around it or a valley with a lake and a
            /// shore around the lake, the player can enter and walk the hall or
            /// the shores.
            Hall,
            /// E.g., a lake or a mount the player can not enter.
            Fill,
        }
    }
}